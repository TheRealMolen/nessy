
	include "nesdefs.dasm"

;;; MACROS


OAM_FLIPX = $40


; Arithmetic shift right A
        MAC _ASR
        cmp #$80
        ror
        ENDM


; InitSprite  spr, x, y, tile
        MAC InitSprite
        lda #{1}
        asl
        asl
        tax
        lda #{3}
        sta OAM_RAM,x
        lda #{4}
        sta OAM_RAM+1,x
        lda #{2}
        sta OAM_RAM+3,x
        ENDM
        
        
;;;;; VARIABLES

	seg.u ZEROPAGE
	org $0
        
; "registers"
r0	byte
r1	byte

rand	byte

;; gamestate - 0 is intro, 1 is gameplay
state	byte

timr	byte
pad0	byte

sam_x	word
sam_y	byte
sam_vx	byte
sam_maxspd byte
sam_oam_attrs	byte
sam_fr	byte
sam_tmr	byte


world_inc byte
scrollx word
flipbg  byte	; when this is true, we need to handle bg flipping next nmi

title_skip byte
title_fade byte

pu_state ds.b num_pickups


;;;;; NES CARTRIDGE HEADER

	NES_HEADER 0,2,1,NES_MIRR_VERT ; mapper 0, 2 PRGs, 1 CHR, horiz. mirror
        

;;;;; START OF CODE

Start:
; wait for PPU warmup; clear CPU RAM
	NES_INIT	; set up stack pointer, turn off PPU
        jsr WaitSync	; wait for VSYNC
        jsr ClearRAM	; clear RAM
        jsr WaitSync	; wait for VSYNC (and PPU warmup)
; set palette and nametable VRAM
	jsr SetPalette	; set palette colors
        
        ; load map
        jsr LoadMap
        ; print the delivery request into bg2
        lda #$2C
        jsr PrintDeliveryRequest
        
                
;;;; init sprites
        
        ;; init motes
        InitSprite $20, $33, $10, $16
        InitSprite $21, $77, $26, $17
        InitSprite $22, $46, $14, $18
        InitSprite $23, $11, $61, $16
        InitSprite $24, $76, $a2, $17
        InitSprite $25, $a0, $13, $18
        InitSprite $26, $e3, $b2, $16
        InitSprite $27, $c1, $51, $17
        InitSprite $28, $e4, $73, $18
        InitSprite $29, $b3, $b5, $16
        InitSprite $2a, $91, $d6, $17
        InitSprite $2b, $48, $e9, $18
        InitSprite $2c, $40, $93, $16
        InitSprite $2d, $33, $b5, $17
        InitSprite $2e, $83, $64, $18
        InitSprite $2f, $d8, $e9, $16
        ; flip some
        lda #OAM_FLIPX
        sta OAM_RAM+2+$20*4
        sta OAM_RAM+2+$22*4
        sta OAM_RAM+2+$23*4
        sta OAM_RAM+2+$24*4
        sta OAM_RAM+2+$28*4
        sta OAM_RAM+2+$2a*4
        sta OAM_RAM+2+$2e*4
        
;;;;; init objects
	lda #$78
        sta sam_x
        lda #$b6
        sta sam_y
        
        ;;;;; DEBUG HACK!
        lda #1
        sta pu_state+0
        sta pu_state+1
        
;;;;; setup ppu
        lda #$18
        sta PPU_MASK 	; enable rendering
        lda #CTRL_NMI
        sta PPU_CTRL	; enable NMI
        

;;;;; start of frame

Tick:
	lda state
        beq update_title
        jmp common_update

update_title:
	lda scrollx
        and #$1
        bne common_update
        inc title_fade
        bne common_update
        inc state

common_update:
	;; reset our world increment for this frame
	lda #0
	sta world_inc
        
	jsr UpdateSam
        
;; handle any push scrolling that sam did
	lda world_inc
	tax
.scroll_loop
        beq .no_scroll
        inc scrollx
        bne .simple_scroll
	;; we've just advanced a whole double-bg
        inc scrollx+1
        lda #1
        sta flipbg	; we need to handle bg flipping logic
.simple_scroll
        inx
        jmp .scroll_loop
.no_scroll
        
        jsr UpdateMotes
        
; build oam buffer
	ldx #0
        jsr RenderSam
        jsr RenderPickups
        
        lda state
        bne no_render_title
        jsr RenderTitle
no_render_title:
	;; HACK: blank out title sprites
        lda #$ff
.blankspriteloop
        sta OAM_RAM,x
        inx	; lol, inxs
        inx
        inx
        inx
        cpx #$80
        bne .blankspriteloop
        
        

;;;;; end of frame
	;; TODO: move to NMI handler!
	jsr WaitSync

; handle any bg updates
	lda flipbg
        beq .post_flipbg
        lda scrollx+1
        cmp #2
        beq .move_req_msg
        cmp #3
        beq .wipe_req_msg
        jmp .bg_flip_done
.move_req_msg
	lda #$2c
        jsr ClearDeliveryRequest
        lda #20
        jsr PrintDeliveryRequest
        jmp .bg_flip_done
.wipe_req_msg
	lda #$20
        jsr ClearDeliveryRequest
.bg_flip_done
	lda #0
        sta flipbg
.post_flipbg
        
        
; copy oam
	lda #0
        sta OAM_ADDR
        lda #2
        sta OAM_DMA
        
; setup scroll
        lda scrollx
        sta PPU_SCROLL
        lda #0
        sta PPU_SCROLL
	lda scrollx+1	; load high byte
        and #1		; select its low bit
	ora #CTRL_NMI	; set rest of bits
        sta PPU_CTRL
        
; activate PPU graphics
        jsr ReadJoypad0
        sta pad0
        jmp Tick
        
        


UpdateSam: subroutine
;; update max speed
        ldx #0
        lda #0
        clc
.pu_loop
	;; NB if the pu state is ever more complex than 1/0, this is broked
	adc pu_state,x
        inx
        cpx #num_pickups
        bne .pu_loop
        ; now lookup our max speed
        tax
        lda pu_maxspeed,x
        sta sam_maxspd

;;; update facing
	lda pad0
        and #$2
        bne .left
	lda pad0
        and #$1
        bne .right
        jmp .friction
.left:
	lda sam_vx
        cmp #-12
        beq .minspd
        dec sam_vx
        cmp #1
        bmi .minspd
        dec sam_vx
.minspd:
; set flipx flag
	lda sam_oam_attrs
	ora #$40
        sta sam_oam_attrs
	jmp .updateanim
.right:
	lda sam_vx
        cmp #12
        beq .maxspd
        ; bonus turnaround
        inc sam_vx
        cmp #-1
        bpl .maxspd
        inc sam_vx
.maxspd:
; clear flipx flag
	lda sam_oam_attrs
        and #$bf
        sta sam_oam_attrs
	jmp .updateanim
        
.friction
	lda sam_vx
        cmp #0
        bmi .incvel
        beq .endfric
.decvel
	clc
        sbc #0
	sta sam_vx
	jmp .endfric
.incvel
	sec
        adc #1
	sta sam_vx
.endfric
	lda sam_vx
        bne .updateanim
        sta sam_fr	; if sam isn't moving, his legs should be still
        sta sam_tmr	; ...and his anim timer should reset so there's instant feedback on starting to move
        jmp .postanim
.updateanim
        dec sam_tmr
        bpl .postanim
        lda sam_fr	; update animation frame
    	eor #1
        sta sam_fr
        lda #14		; reset timer
        sta sam_tmr
.postanim
        

; update sam x pos
screen_clamp_point = 10
push_scroll_point = $88

	lda sam_vx
        _ASR		; vx /= 4
        _ASR
        clc		; add on sam's x pos
        adc sam_x
        ; [not in push scroll adc world_inc	; plus the world scroll pos
        cmp #screen_clamp_point
        bcs .not_at_left
        lda sam_vx
        bpl .moving_on_up
        lda #0
        sta sam_vx
        sta sam_fr
.moving_on_up
        lda #screen_clamp_point
        jmp .updated_x
.not_at_left
	; do we need to push scroll?
        cmp #push_scroll_point
        bcc .updated_x
        ; yep! figure out how much by...
        sta r0
        lda #push_scroll_point
        sec
        sbc r0
        sta world_inc
        lda #push_scroll_point
.updated_x
        sta sam_x

	rts
        
        
;; build oam buf for sam
;;;; starting oam offset goes in X (and new one is returned in x)
RenderSam: subroutine
        lda sam_y	; store a copy of sam y
        pha
   	sec
        sbc #$10
        sta sam_y
        lda sam_oam_attrs ; load sprite attrs (flipx)
        ora #$01	; set palette 1
        sta r0		; r0 = attrs
        lda #$b0	; tiles are vertical from b0
        clc
        adc sam_fr	; anim frames are columns
        pha		; tile goes onto stack
        lda #0
        sta r1		; tile * row in r1
        ldx #0		; sprites 0, 1, 2
        ldy #3		; sam is 3 tall
.loop
        lda sam_y	; set sprite y
        sta OAM_RAM,x
        adc #8
        sta sam_y
        inx
        pla		; set sprite tile
        pha
        clc
        adc r1
        sta OAM_RAM,x
        inx
        lda r0		; set sprite attrs
        sta OAM_RAM,x
        inx
        lda sam_x	; set sprite x
        sta OAM_RAM,x
        inx
        lda r1		; inc tile row
        clc
        adc #$10
        sta r1
        
        dey		; loop
        bne .loop
        pla		; pull the tile off the stack
        pla
        sta sam_y
        rts
        
        
;;;; starting oam offset goes in X (and new one is returned in x)
RenderPickups: subroutine
	lda sam_x	; put carry pos in r0
        sta r0
        
        ;; store backpack inc in r1 (and update initial pos)
        lda sam_oam_attrs ; load sprite attrs (flipx)
        and #OAM_FLIPX
        beq .face_right
.face_left        
        lda #-4		; inc per backpack is -4
        sta r1
        lda r0
	clc
        adc #3
        sta r0
        jmp .done_flip
.face_right
	lda #4		; inc per backpack is 4
        sta r1		; r1 is backpack inc
        lda r0		; adjust initial pos
	sec
        sbc #8
        sta r0 
.done_flip
	ldy #0		; y is curr pickup
        
.loop
	lda pu_state,y
        beq .on_ground

.on_back
	lda sam_y	; sprite y is on sam's back
        sec
        sbc #10
        sta OAM_RAM,x
        inx
        lda #pickup_carry_tile	; sprite tile is static
        sta OAM_RAM,x
        inx
        lda #1		; set sprite attrs (shares a pal with sam, never flips x)
        sta OAM_RAM,x
        inx
        lda r0		; sprite x is behind sam
        sta OAM_RAM,x
        inx
        sec
      	sbc r1
        sta r0
        
        jmp .end_pu
        
.on_ground
        lda #$ff	; set sprite y
        sta OAM_RAM,x
        inx
        lda #pickup_static_tile
        sta OAM_RAM,x
        inx
        lda #1		; set sprite attrs (shares a pal with sam, never flips x)
        sta OAM_RAM,x
        inx
        lda #70	; set sprite x
        sta OAM_RAM,x
        inx
        
.end_pu
        iny		; loop
        cpy #num_pickups
        bne .loop
	rts
        
        
        
        
UpdateMotes: subroutine
; update animation timer
	inc timr
        lda #3
        cmp timr
        bne .done_timr
        lda #0
        sta timr
.done_timr
	bne .done

	ldx #$20 * 4
        ldy #$10
.loop:
	dec OAM_RAM,x	; dec spr.y
        lda world_inc
        clc
        adc OAM_RAM+3,x
        sta OAM_RAM+3,x

	; move to next sprite
        inx
        inx
        inx
        inx
        dey
	bne .loop	; loop
.done
        rts		; return to caller





LoadMap: subroutine
	; bg 0
	PPU_SETADDR $22c0
        ldx #0
.loop
	lda land_ground,x
        sta PPU_DATA
        inx
        bne .loop
.loop_attr
	lda land_attrs,x
        sta PPU_DATA
        inx
        cpx #$40
        bne .loop_attr
        
        ; bg 1
	PPU_SETADDR $26c0
        ldx #0
.loop2
	lda land_ground,x
        sta PPU_DATA
        inx
        bne .loop2
.loop2_attr
	lda land_attrs,x
        sta PPU_DATA
        inx
        cpx #$40
        bne .loop2_attr
        
        rts
        



; set palette colors
SetPalette: subroutine
; set PPU address to palette start
	PPU_SETADDR $3f00
        ldy #0
.loop:
	lda Palette,y	; lookup byte in ROM
	sta PPU_DATA	; store byte to PPU data
        iny		; Y = Y + 1
        cpy #32		; is Y equal to 32?
	bne .loop	; not yet, loop
        rts		; return to caller
       

	include "messages.dasm"


;;;;; COMMON SUBROUTINES

	include "nesppu.dasm"
        
       
Rand: subroutine
	txa
        pha
	lda rand
        tax
        lda rand_table,x
        sta rand
        pla
        tax
        lda rand
	rts

;;;;; INTERRUPT HANDLERS

NMIHandler:
	rti		; return from interrupt

;;;;; CONSTANT DATA

Palette:
	hex 2d		;screen color
	hex 09081d	;background 0 - foreground
        hex 25		; bg1 unused
        hex 1d181b	;background 1 - background
        hex 25		; bg2 unused
        hex 07170c	;background 2 - penny
        hex 25		; bg3 unused
        hex 311d0f	;background 3 - text
        hex 3d		;screen colour MIRROR
        hex 001d0f	;sprite 0 -- motes
        hex 25		; bg1 unused MIRROR
        hex 0d1727	;sprite 1 -- sam & pickups
        hex 25		; bg2 unused MIRROR
        hex 252525	;sprite 2
        hex 25		; bg3 unused MIRROR
        hex 252525	;sprite 3
        
        
        align $100
	include "rand.asm"
        
        include "pickups.asm"

        
 	include "land.asm"

;;;;; CPU VECTORS

	NES_VECTORS

;;;;; TILE SETS

	org $10000
        incbin "strand.chr"
        incbin "strand.chr"
