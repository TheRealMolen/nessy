
	include "nesdefs.dasm"

;;; MACROS


OAM_FLIPX = $40


; Arithmetic shift right A
        MAC _ASR
        cmp #$80
        ror
        ENDM


; InitSprite  spr, x, y, tile
        MAC InitSprite
        lda #{1}
        asl
        asl
        tax
        lda #{3}
        sta OAM_RAM,x
        lda #{4}
        sta OAM_RAM+1,x
        lda #{2}
        sta OAM_RAM+3,x
        ENDM
        
        
;;;;; VARIABLES

	seg.u ZEROPAGE
	org $0
        
; "registers"
r0	byte
r1	byte

timr	byte
pad0	byte

sam_x	byte
sam_y	byte
sam_vx	byte
sam_oam_attrs	byte
sam_fr	byte
sam_tmr	byte

world_inc byte
scrollx word


;;;;; NES CARTRIDGE HEADER

	NES_HEADER 0,2,1,NES_MIRR_VERT ; mapper 0, 2 PRGs, 1 CHR, horiz. mirror
        

;;;;; START OF CODE

Start:
; wait for PPU warmup; clear CPU RAM
	NES_INIT	; set up stack pointer, turn off PPU
        jsr WaitSync	; wait for VSYNC
        jsr ClearRAM	; clear RAM
        jsr WaitSync	; wait for VSYNC (and PPU warmup)
; set palette and nametable VRAM
	jsr SetPalette	; set palette colors
        
        ; load map
        jsr LoadMap
        
                
;;;; init sprites
	; many stars
	lda #$18   ; star!
        ldx #$20 * 4
        ldy #0
init_sprite_loop:
	inx
	sta OAM_RAM,x
        inx
        inx
        inx
        iny
        cpy #$10
        bne init_sprite_loop
        
        ;; init sam (palette 1)
        ;InitSprite $0, $78, $ae, $b0
        ;InitSprite $1, $78, $b6, $c0
        ;InitSprite $2, $78, $be, $d0
        ;lda #$01
        ;sta OAM_RAM+2
        ;sta OAM_RAM+6
        ;sta OAM_RAM+10
        
        ;; init title
        InitSprite $04, $58, $50, $47	; G
        InitSprite $05, $68, $50, $45	; E
        InitSprite $06, $78, $50, $4f	; O
        InitSprite $07, $88, $50, $46	; F
        InitSprite $08, $98, $50, $46	; F
        InitSprite $09, $38, $63, $53	; S
        InitSprite $0a, $48, $63, $54	; T
        InitSprite $0b, $58, $63, $52	; R
        InitSprite $0c, $68, $63, $41	; A
        InitSprite $0d, $78, $63, $4e	; N
        InitSprite $0e, $89, $63, $44	; D
        InitSprite $0f, $98, $63, $49	; I
        InitSprite $10, $a7, $63, $4e	; N
        InitSprite $11, $b8, $63, $47	; G
        
        ;; init motes
        InitSprite $20, $33, $10, $16
        InitSprite $21, $77, $26, $17
        InitSprite $22, $46, $14, $18
        InitSprite $23, $11, $61, $16
        InitSprite $24, $76, $a2, $17
        InitSprite $25, $a0, $13, $18
        InitSprite $26, $e3, $b2, $16
        InitSprite $27, $c1, $51, $17
        InitSprite $28, $e4, $73, $18
        InitSprite $29, $b3, $b5, $16
        InitSprite $2a, $91, $d6, $17
        InitSprite $2b, $48, $e9, $18
        InitSprite $2c, $40, $93, $16
        InitSprite $2d, $33, $b5, $17
        InitSprite $2e, $83, $64, $18
        InitSprite $2f, $d8, $e9, $16
        ; flip some
        lda #OAM_FLIPX
        sta OAM_RAM+2+$20*4
        sta OAM_RAM+2+$21*4
        sta OAM_RAM+2+$23*4
        sta OAM_RAM+2+$25*4
        sta OAM_RAM+2+$27*4
        sta OAM_RAM+2+$2a*4
        sta OAM_RAM+2+$2f*4
        
;;;;; init objects
	lda #$78
        sta sam_x
        lda #$be
        sta sam_y
        

;;;;; start of frame

Tick:
; update posx
	lda #0
	sta world_inc
	inc timr
        lda #3
        cmp timr
        bne endupdate_posx
        dec world_inc
        jsr UpdateMotes
        inc scrollx
        bne .scrollx_done
        inc scrollx+1
.scrollx_done
        lda #0
        sta timr
endupdate_posx:

	jsr UpdateSam

        
;;;;; end of frame

; build oam buffer
	ldx #0
        jsr RenderSam
        

; reset PPU address and scroll registers
        lda #0
        sta PPU_ADDR
        sta PPU_ADDR	; PPU addr = $0000
        lda scrollx
        sta PPU_SCROLL
        lda #0
        sta PPU_SCROLL  ; PPU scroll = $0000
        lda #CTRL_NMI
        sta PPU_CTRL	; enable NMI
        jsr WaitSync
        
; copy oam
	lda #0
        sta OAM_ADDR
        lda #2
        sta OAM_DMA
; activate PPU graphics
        lda #$1e
        sta PPU_MASK 	; enable rendering
        jsr ReadJoypad0
        sta pad0
        jmp Tick
        
        


UpdateSam: subroutine

;;; update facing
	lda pad0
        and #$2
        bne .left
	lda pad0
        and #$1
        bne .right
        jmp .friction
.left:
	lda sam_vx
        cmp #-12
        beq .minspd
        dec sam_vx
        cmp #1
        bmi .minspd
        dec sam_vx
.minspd:
; set flipx flag
	lda sam_oam_attrs
	ora #$40
        sta sam_oam_attrs
	jmp .enddir
.right:
	lda sam_vx
        cmp #12
        beq .maxspd
        ; bonus turnaround
        inc sam_vx
        cmp #-1
        bpl .maxspd
        inc sam_vx
.maxspd:
; clear flipx flag
	lda sam_oam_attrs
        and #$bf
        sta sam_oam_attrs
	jmp .enddir
        
.friction
	lda sam_vx
        cmp #0
        bmi .incvel
        beq .enddir
.decvel
	clc
        sbc #0
	sta sam_vx
	jmp .enddir
.incvel
	sec
        adc #1
	sta sam_vx
.enddir


    ; lda i
    ; cmp j
    ; bmi .i_lt_j
    ; bpl .i_ge_j
    ; bcs .i_le_j
    ; bcc .i_gt_j
        
        

; update sam x pos  
	lda sam_vx
        _ASR		; vx /= 4
        _ASR
        clc
        adc sam_x
        adc world_inc
        cmp #10
        bcs .not_at_left
        lda #10
.not_at_left
        sta sam_x
        
        sta OAM_RAM+3
        sta OAM_RAM+7
        sta OAM_RAM+11

	rts
        
        
;; build oam buf for sam
;;;; starting oam offset goes in X (and new one is returned in x)
RenderSam: subroutine
        lda sam_y	; store a copy of sam y
        pha
   	sec
        sbc #$10
        sta sam_y
        lda sam_oam_attrs ; load sprite attrs (flipx)
        ora #$01	; set palette 1
        sta r0		; r0 = attrs
        lda #$b0	; tiles are vertical from b0
        clc
        adc sam_fr	; anim frames are columns
        pha		; tile goes onto stack
        lda #0
        sta r1		; tile * row in r1
        ldx #0		; sprites 0, 1, 2
        ldy #3		; sam is 3 tall
.samloop
        lda sam_y	; set sprite y
        sta OAM_RAM,x
        adc #8
        sta sam_y
        inx
        pla		; set sprite tile
        pha
        clc
        adc r1
        sta OAM_RAM,x
        inx
        lda r0		; set sprite attrs
        sta OAM_RAM,x
        inx
        lda sam_x	; set sprite x
        sta OAM_RAM,x
        inx
        lda r1		; inc tile row
        clc
        adc #$10
        sta r1
        
        dey		; loop
        bne .samloop
        pla		; pull the tile off the stack
        pla
        sta sam_y
        rts
        
        
        
        
UpdateMotes: subroutine
	ldx #$20 * 4
.loop:
	dec OAM_RAM,x	; dec spr.y
        lda world_inc
        clc
        adc OAM_RAM+3,x
        sta OAM_RAM+3,x

	; move to next sprite
        inx
        inx
        inx
        inx
	cpx #$40 + (#$21 * 4)
	bne .loop	; loop
        rts		; return to caller





LoadMap: subroutine
map_rows = 4
attr_table_len = $40
	; bg 0
	PPU_SETADDR $2300
        ldx #0
.loop
	lda land_ground,x
        sta PPU_DATA
        inx
        cpx #$20 * map_rows + attr_table_len
        bne .loop
        
        ; bg 1
	PPU_SETADDR $2700
        ldx #0
.loop2
	lda land_ground,x
        sta PPU_DATA
        inx
        cpx #$20 * map_rows + attr_table_len
        bne .loop2
        
        rts
        



; set palette colors
SetPalette: subroutine
; set PPU address to palette start
	PPU_SETADDR $3f00
        ldy #0
.loop:
	lda Palette,y	; lookup byte in ROM
	sta PPU_DATA	; store byte to PPU data
        iny		; Y = Y + 1
        cpy #32		; is Y equal to 32?
	bne .loop	; not yet, loop
        rts		; return to caller



;;;;; COMMON SUBROUTINES

	include "nesppu.dasm"

;;;;; INTERRUPT HANDLERS

NMIHandler:
	rti		; return from interrupt

;;;;; CONSTANT DATA

Palette:
	hex 01		;screen color
	hex 09081d3d	;background 0 - foreground
        hex 25252525	;background 1 - background
        hex 00000000	;background 2
        hex 0000002d	;background 3
        hex 00000f0f	;sprite 0
        hex 08171725	;sprite 1 -- sam
        hex 142b3b25	;sprite 2
        hex 1c2c3c25	;sprite 3
        
        
 	include "land.asm"
 	include "bg.asm"

;;;;; CPU VECTORS

	NES_VECTORS

;;;;; TILE SETS

	org $10000
        incbin "strand.chr"
        incbin "strand.chr"
