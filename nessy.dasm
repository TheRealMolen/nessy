
	include "nesdefs.dasm"

;;; MACROS

; Arithmetic shift right A
        MAC _ASR
        cmp #$80
        ror
        ENDM


; InitSprite  spr, x, y, tile
        MAC InitSprite
        lda #{1}
        asl
        asl
        tax
        lda #{3}
        sta OAM_RAM,x
        lda #{4}
        sta OAM_RAM+1,x
        lda #{2}
        sta OAM_RAM+3,x
        ENDM
        
        
;;;;; VARIABLES

	seg.u ZEROPAGE
	org $0
        
timr	byte
pad0	byte

kr_x	byte
kr_vx	byte


;;;;; NES CARTRIDGE HEADER

	NES_HEADER 0,2,1,0 ; mapper 0, 2 PRGs, 1 CHR, horiz. mirror
        

;;;;; START OF CODE

Start:
; wait for PPU warmup; clear CPU RAM
	NES_INIT	; set up stack pointer, turn off PPU
        jsr WaitSync	; wait for VSYNC
        jsr ClearRAM	; clear RAM
        jsr WaitSync	; wait for VSYNC (and PPU warmup)
; set palette and nametable VRAM
	jsr SetPalette	; set palette colors
        
;;;; init bg
        jsr HelloVRAM	; print message in name table
        
        
        
                
;;;; init sprites
	; many stars
	lda #$18   ; star!
        ldx #$20 * 4
        ldy #0
init_sprite_loop:
	inx
	sta OAM_RAM,x
        inx
        inx
        inx
        iny
        cpy #$10
        bne init_sprite_loop
        
        ;; init kris (palette 1)
        InitSprite $0, $78, $a0, $b0
        InitSprite $1, $78, $a8, $c0
        InitSprite $2, $78, $b0, $d0
        lda #$01
        sta OAM_RAM+2
        sta OAM_RAM+6
        sta OAM_RAM+10
        
        InitSprite $20, $24, $33, $b6
        InitSprite $21, $77, $26, $18
        InitSprite $22, $46, $14, $18
        InitSprite $23, $11, $61, $18
        InitSprite $24, $76, $a2, $18
        InitSprite $25, $a0, $13, $18
        InitSprite $26, $e3, $b2, $18
        InitSprite $27, $c1, $51, $18
        InitSprite $28, $e4, $73, $18
        InitSprite $29, $b3, $b5, $18
        InitSprite $2a, $91, $d6, $18
        InitSprite $2b, $48, $e9, $18
        InitSprite $2c, $40, $93, $18
        InitSprite $2d, $33, $b5, $18
        InitSprite $2e, $83, $64, $18
        InitSprite $2f, $d8, $e9, $18
        
;;;;; init objects
	lda #$78
        sta kr_x
        

;;;;; start of frame

Tick:
; update posx
	inc timr
        lda #3
        cmp timr
        bne endupdate_posx
        jsr UpdateStars
        lda #0
        sta timr
endupdate_posx:

        ;understanding flags with adc
        ; if A + (mem) flips A -ve, N bit is set
        ;lda #-4
        ;sta pad0
        ;lda #5
        ;clc
        ;adc pad0
        ;nop

	jsr UpdateKris

        
;;;;; end of frame

; reset PPU address and scroll registers
        lda #0
        sta PPU_ADDR
        sta PPU_ADDR	; PPU addr = $0000
        sta PPU_SCROLL
        sta PPU_SCROLL  ; PPU scroll = $0000
        lda #CTRL_NMI
        sta PPU_CTRL	; enable NMI
        jsr WaitSync
        
; copy oam
	lda #0
        sta OAM_ADDR
        lda #2
        sta OAM_DMA
; activate PPU graphics
        lda #$1e
        sta PPU_MASK 	; enable rendering
        jsr ReadJoypad0
        sta pad0
        jmp Tick
        
        

;;;; update kris
UpdateKris: subroutine

;;; update facing
	lda pad0
        and #$2
        bne .left
	lda pad0
        and #$1
        bne .right
        jmp .friction
.left:
	lda kr_vx
        cmp #-16
        beq .minspd
        dec kr_vx
        cmp #1
        bmi .minspd
        dec kr_vx
.minspd:
; set flipx flag
	lda OAM_RAM+2
	ora #$40
        sta OAM_RAM+2
        sta OAM_RAM+6
        sta OAM_RAM+10
	jmp .enddir
.right:
	lda kr_vx
        cmp #16
        beq .maxspd
        ; bonus turnaround
        inc kr_vx
        cmp #-1
        bpl .maxspd
        inc kr_vx
.maxspd:
; clear flipx flag
	lda OAM_RAM+2
        and #$bf
        sta OAM_RAM+2
        sta OAM_RAM+6
        sta OAM_RAM+10
	jmp .enddir
        
.friction
	lda kr_vx
        cmp #0
        bmi .incvel
        beq .enddir
.decvel
	clc
        sbc #0
	sta kr_vx
	jmp .enddir
.incvel
	sec
        adc #1
	sta kr_vx
.enddir


    ; lda i
    ; cmp j
    ; bmi .i_lt_j
    ; bpl .i_ge_j
    ; bcs .i_le_j
    ; bcc .i_gt_j

; clamp kris to screen
	lda kr_vx
        lda #$8
        cmp #0
        bmi .clampleft
        beq .doneclampx
.clampright
	lda #$f0
        cmp kr_x
        bcs .doneclampx
        lda #0
        sta kr_vx
	jmp .doneclampx
.clampleft
	lda kr_x
        cmp #$6
        bcs .doneclampx
        lda #0
        sta kr_vx
	jmp .doneclampx
.doneclampx
        
        
        

; update kris x pos  
	lda kr_vx
        _ASR		; vx /= 4
        _ASR
        clc
        adc kr_x
        sta kr_x
        
        sta OAM_RAM+3
        sta OAM_RAM+7
        sta OAM_RAM+11


	rts
        
        
        
        
UpdateStars: subroutine
	ldx #$20 * 4
.loop:
	inc OAM_RAM,x	; inc spr.y
        lda #$f8	; spr.x &= $f8  (bottom 3 bits 0)
        and OAM_RAM+3,x
        sta OAM_RAM+3,x
        lda OAM_RAM,x	; A = spr.y & $f
        and #$f
        lsr		; A >>= 1   (A is 3 bits)
        cmp #4		; N = (A - 4 < 0)
        bmi .add_dx	; if (A >= 4) then
        eor #$ff	;    A = -A
        clc
        adc #8
.add_dx
	clc
        adc OAM_RAM+3,x
        sta OAM_RAM+3,x
        
	; move to next sprite
	txa
        clc
        adc #4
        tax
	cpx #$40 + (#$21 * 4)
	bne .loop	; loop
        rts		; return to caller









; set palette colors
SetPalette: subroutine
; set PPU address to palette start
	PPU_SETADDR $3f00
        ldy #0
.loop:
	lda Palette,y	; lookup byte in ROM
	sta PPU_DATA	; store byte to PPU data
        iny		; Y = Y + 1
        cpy #32		; is Y equal to 32?
	bne .loop	; not yet, loop
        rts		; return to caller

; fill video RAM with title text
HelloVRAM: subroutine
	PPU_SETADDR $214b
	ldy #0		; set Y counter to 0
.loop:
	lda TitleMsg1,y	; get next character
        beq .end	; is 0? exit loop
	sta PPU_DATA	; store+advance PPU
        iny		; next character
	bne .loop	; loop
.end
	PPU_SETADDR $21a7
	ldy #0		; set Y counter to 0
.loop2:
	lda TitleMsg2,y	; get next character
        beq .end2	; is 0? exit loop
	sta PPU_DATA	; store+advance PPU
        iny		; next character
	bne .loop2	; loop
.end2
        rts		; return to caller; fill video RAM with "Hello World" msg

; clear a chunk of video ram
; PPU ADDR needs to have been set with target pos before calling
; Acc is the clear length
ClearLine: subroutine
	ldx #0
.loop:
	stx PPU_DATA	; store+advance PPU
        sbc #1
	bcs .loop	; loop
        rts		; return to caller

; ASCII message to display on screen
TitleMsg1:
	.byte "D E A T H"
        .byte 0
TitleMsg2:
        .byte "S T R A N D I N G"
        .byte 0		; zero terminator
        
        




;;;;; COMMON SUBROUTINES

	include "nesppu.dasm"

;;;;; INTERRUPT HANDLERS

NMIHandler:
	rti		; return from interrupt

;;;;; CONSTANT DATA

Palette:
	hex 01		;screen color
	hex 10001d01	;background 0 (title text)
        hex 00000000	;background 1
        hex 00000000	;background 2
        hex 00000020	;background 3
        hex 2022d025	;sprite 0
        hex 08171725	;sprite 1 -- kris
        hex 142b3b25	;sprite 2
        hex 1c2c3c25	;sprite 3

;;;;; CPU VECTORS

	NES_VECTORS

;;;;; TILE SETS

	org $10000
        incbin "strand.chr"
        incbin "strand.chr"
